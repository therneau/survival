\subsubsection{Printing and plotting}
The \code{survfitms} class differs from a \code{survfit}, but many of the
same methods nearly apply.
<<survfitms>>=
# Methods for survfitms objects
<<survfitms-summary>>
<<survfitms-subscript>>
@ 

The subscript method is a near copy of that for survfit
objects, but with a slightly different set of components.
The object could have strata and will almost always have multiple
columns. Following convention, if there is only one subscript we treat
the object as though it were a vector.
The \code{nmatch} function allow the user to use either names
or integer indices.

<<survfitms-subscript>>=
"[.survfitms" <- function(x, ..., drop=FALSE) {
    nmatch <- function(i, target) { 
        # This function lets R worry about character, negative, 
        # or logical subscripts
        #  It always returns a set of positive integer indices
        temp <- seq(along=target)
        names(temp) <- target
        temp[i]
    }
    x <- survfit23(x)   # otherwise influence and pstate don't align
    ndots <- ...length()   # number of subscripts that we have
    dd <- dim(x)
    dtype <- match(names(dd), c("strata", "data", "states"))
    if (is.null(x$states)) stop("survfitms object has no states component")
    if (ndots==0) return(x)  # no subscript given
    if (ndots >0 && !missing(..1)) i <- ..1 else i <- NULL
    if (ndots> 1 && !missing(..2)) j <- ..2 else j <- NULL
    if (ndots> 2 && !missing(..3)) k <- ..3 else k <- NULL
    if (ndots >3) stop("too many subscripts for survfit object")
    if (is.null(i) & is.null(j) & is.null(k)) return(x)

    # We need to make a new one
    newx <- vector("list", length(x))
    names(newx) <- names(x)
    for (k in c("logse", "version", "conf.int", "conf.type", "type", "call"))
        if (!is.null(x[[k]])) newx[[k]] <- x[[k]]
    class(newx) <- class(x)

    # From a user's point of view the data and state dimensions are
    #  separate, but in the object these two are combined and appear as the
    #  columns of pstate.
    #
    if (ndots==1 && length(dd) > 1) {
        # the 'treat it as a vector' case
        # if only one dimension is >1, it is easier to expand out i,j,k
        if (length(dd[dd>1]) ==1) {
            if (dd[1] > 1) {j <-NULL; k <- NULL};
            if (dd[3] > 1 || dtype[2]==3) {k <- i;  i <-NULL; j<- NULL}
            else { j<- i; i<-NULL; k<-NULL }
        }
        else {
            if (!is.numeric(i))
                stop("single subscript must be numeric")
            # when subscripting a mix, these don't endure
            newx$cumhaz <- newx$std.chaz <- newx$influence.chaz <- NULL
            newx$transitions <- newx$states <- newx$newdata <- NULL

            # what strata and columns do I need?
            itemp <- matrix(1:prod(dd), nrow=dd[1])
            jj <- (col(itemp))[i]    # columns
            ii <- (row(itemp))[i]    # this is now the strata id
            
            if (dd[1]==1) irow <- rep(seq(along= x$time), length(ii))
            else {
                itemp2 <- split(1:sum(x$strata), rep(1:length(x$strata), x$strata))
                irow <- unlist(itemp2[ii])  # rows of the pstate object
            }
            inum <- x$strata[ii]        # number of rows in each ii
            indx <- cbind(irow, rep(jj,ii))      # matrix index for pstate
           
            # The n.risk, n.event, .. matrices dont have a newdata dimension.
            if (dtype[2]==3 || dd[2]==1) kk <- jj
            else {  # all three indices
                itemp <- matrix(1:(dd[2]*dd[3]), nrow=dd[2])
                kk <- (col(itemp))[jj]    # the state of each selected one
                indx2 <- cbind(irow, rep(k, irow))  
            }
            newx$n <- x$n[ii]
            newx$time <- x$time[irow]
            for (z in c("n.risk", "n.event", "n.censor", "n.enter"))
                if (!is.null(x[[z]])) newx[[z]] <- (x[[z]])[indx2]
            for (z in c("pstate", "std.err", "upper", "lower"))
                if (!is.null(x[[z]])) newx[[z]] <- (x[[z]])[indx]
  
            newx$strata <- x$strata[ii]
            names(newx$strata) <- seq(along=ii)

            return(newx)
        }
    }
    
    # not a single subscript, i.e., the usual case
    if (ndots != length(dd)) stop("incorrect number of dimensions")
    if (is.null(i)) i <- seq.int(dd[1])
    else i <- nmatch(i, names(x$strata))
    if (dd[1] ==1) irow <- rep(seq(along=x$time), length(i))
    else {
        itemp <- split(1:sum(x$strata), rep(1:length(x$strata), x$strata))
        irow <- unlist(itemp[i])  # rows of the pstate object
    }
    newx$n <- x$n[i]
    newx$time <- x$time[irow]
    for (z in c("n.censor", "n.enter"))
        if (!is.null(x[[z]])) newx[[z]] <- (x[[z]])[irow, drop=FALSE]
    
    # two cases: with newx or without newx  (pstate is always present)
    nstate <- length(x$states)
    if (length(dd) ==2) {  # j indexes the states
        if (is.null(j)) j <- seq.int(nstate)
        else j <- nmatch(j, x$states)
         
        if (length(i) ==1 && drop) newx$strata <- NULL
        else newx$strata <- x$strata[i]

        # in the rare case of a single strata with 1 obs, don't drop dims
        if (length(irow)==1 && length(j) > 1) drop2 <- FALSE 
        else drop2 <- drop

        for (z in c("n.risk", "n.event"))
            if (!is.null(x[[z]])) newx[[z]] <- (x[[z]])[irow,j, drop=drop2]
        for (z in c("pstate", "std.err", "upper", "lower"))
            if (!is.null(x[[z]])) newx[[z]] <- (x[[z]])[irow,j, drop=drop2]
        if (!is.null(x$influence.pstate)) {
            if (is.list(x$influence.pstate)) {
                if (length(i)==1) newx$influence.pstate <- x$influence.pstate[[i]]
                else newx$influence.pstate <- lapply(x$influence.pstate[i],
                                     function(x) x[,,j, drop= drop])
                }
            else newx$influence.pstate <- x$influence.pstate[,,j, drop=drop]
        }

        if (length(j)== nstate && all(j == seq.int(nstate))) {
            # user kept all the states
            newx$states <- x$states
            for (z in c("cumhaz", "std.chaz"))
                 if (!is.null(x[[z]])) newx[[z]] <- (x[[z]])[irow,, drop=drop2]
            if (!is.null(x$influence.chaz)) {
                if (is.list(x$influence.chaz)) {
                    newx$influence.chaz <- x$influence.chaz[i]
                    if (length(i)==1 && drop) 
                        newx$influence.chaz <- x$influence.chaz[[i]]
                }
                else newx$influence.chaz <- x$influence.chaz
            }
        }
        else {
            newx$cumhaz <- newx$std.chaz <- newx$influence.chaz <- NULL
            if (length(j)==1 & drop) {
                newx$states <- NULL
                temp <- class(newx)
                class(newx) <- temp[temp!="survfitms"]
            }
            else newx$states <- x$states[j]
        }
    }
    else {  # j points at newdata, k points at states
        if (is.null(j)) j <- seq.int(dd[2])
        else j <- nmatch(j, seq.int(dd[2]))

        if (is.null(k)) k <- seq.int(nstate)
        else k <- nmatch(k, x$states)

        jj <- c(matrix(seq.int(dd[2]*dd[3]), nrow=dd[2])[j,k]) # cols of pstate
        if (length(irow)==1) {
            if (length(jj) > 1) drop2 <- FALSE else drop2<- drop
            if (length(k) > 1)  drop3 <- FALSE else drop3 <- drop
        } 
        else drop2 <- drop3 <- drop

        for (z in c("n.risk", "n.event"))
            if (!is.null(x[[z]])) newx[[z]] <- (x[[z]])[irow, k, drop=drop3]
        for (z in c("pstate", "std.err", "upper", "lower"))
            if (!is.null(x[[z]])) newx[[z]] <- (x[[z]])[irow,jj, drop=drop2]
  
        if (!is.null(x$influence.pstate)) {
            if (is.list(x$influence.pstate)) {
                if (length(i)==1) 
                    newx$influence.pstate <- (x$influence.pstate[[i]])[,,jj, drop=drop]
                else newx$influence.pstate <- lapply(x$influence.pstate[i],
                                     function(x) x[,,jj, drop= drop])
                }
            else newx$influence.pstate <- x$influence.pstate[,,jj, drop=drop]
        }

    if (length(k)== nstate && all(k == seq.int(nstate))) {
            # user kept all the states
            newx$states <- x$states
            for (z in c("cumhaz", "std.chaz"))
                 if (!is.null(x[[z]])) 
                     newx[[z]] <- (x[[z]])[irow,jj, drop=drop2]
             if (!is.null(x$influence.chaz)) {
                if (is.list(x$influence.chaz)) {
                    newx$influence.chaz <- x$influence.chaz[i]
                    if (length(i)==1 && drop) 
                        newx$influence.chaz <- x$influence.chaz[[i]]
                }
                else newx$influence.chaz <- x$influence.chaz
            }
       }
        else {
            newx$cumhaz <- newx$std.chaz <- newx$influence.chaz <- NULL
            x$transitions <- NULL
            if (length(k)==1 && drop) {
                newx$states <- NULL
                temp <- class(newx)
                class(newx) <- temp[temp != "survfitms"]
            } else newx$states <- x$states[k]
        }

        if (length(j)==1 && drop) x$newdata <- NULL
 
    }
    newx
}
@ 

The summary.survfit and summary.survfitms functions share a significant
amount of code.  
One part of the code that once was subtle is dealing with
intermediate time points; the findInterval function in base R has
made that much easier.
Since the result does not involve interpolation, one should be able
to create a special index vector i and return \code{time[i]},
\code{surv[i,]}, etc, to subscript all the curves in a survfit object
at once.  But that approach, though efficient in theory, runs into
two problems.  First is the extrapolated value for the curves at
time points before the first event, which is allowed to be different
for different curves in survfitms objects. 
The second is that there is interpolation of a sort: the n.event and n.censor
components are summed over intervals when the selected time points are
sparse, and that process is very tricky for multiple curves at once.
At one point the code took that approach, but it became too complex to maintain.
The current approach is slower but more transparent: do the individual
curves one by one, then paste together the results.

<<survfitms-summary>>=
summary.survfit <- function(object, times, censored=FALSE, 
			    scale=1, extend=FALSE, 
                            rmean=getOption('survfit.rmean'),
                            ...) {
    fit <- survfit23(object)  #make a local copy, and ensure version 3
    if (!inherits(fit, 'survfit'))
	    stop("summary.survfit can only be used for survfit objects")
    if (is.null(fit$logse)) fit$logse <- TRUE   #older style

    # The print.rmean option is depreciated, it is still listened
    #   to in print.survfit, but ignored here
    if (is.null(rmean)) rmean <- "common"
    if (is.numeric(rmean)) {
        if (is.null(object$start.time)) {
            if (rmean < min(object$time)) 
                stop("Truncation point for the mean time in state is < smallest survival")
        }
        else if (rmean < object$start.time)
            stop("Truncation point for the mean time in state is < smallest survival")
    }
    else {
        rmean <- match.arg(rmean, c('none', 'common', 'individual'))
        if (length(rmean)==0) stop("Invalid value for rmean option")
    }

    temp <- survmean(fit, scale=scale, rmean)  
    table <- temp$matrix  #for inclusion in the output list
    rmean.endtime <- temp$end.time
    
    fit$time <- fit$time/scale
    if (!is.null(fit$strata)) {
        nstrat <-  length(fit$strata)
    }    
    delta <- function(x, indx) {  # sums between chosen times
        if (is.logical(indx)) indx <- which(indx)
        if (!is.null(x) && length(indx) >0) {
            fx <- function(x, indx) diff(c(0, c(0, cumsum(x))[indx+1]))
            if (is.matrix(x)) {
                temp <- apply(x, 2, fx, indx=indx)
                # don't return a vector when only 1 time point is given
                if (is.matrix(temp)) temp else matrix(temp, nrow=1)
            }
            else fx(x, indx)
        }
        else NULL
    }

    if (missing(times)) {
        <<survfitms-simple>>
    }
    else {
        <<survfitms-times>>
        times <- sort(times)  #in case the user forgot
        if (is.null(fit$strata)) fit <- findrow(fit, times, extend)
        else {
            ltemp <- vector("list", nstrat)
            for (i in 1:nstrat) 
                ltemp[[i]] <- findrow(fit[i], times, extend)
            fit <- unpacksurv(fit, ltemp)
        }
    }

    # finish off the output structure
    fit$table <- table
    if (length(rmean.endtime)>0  && !any(is.na(rmean.endtime[1]))) 
            fit$rmean.endtime <- rmean.endtime

    # A survfit object may contain std(log S) or std(S), summary always std(S)
    if (!is.null(fit$std.err) && fit$logse) fit$std.err <- fit$std.err * fit$surv 
 
    # Expand the strata
    if (!is.null(fit$strata)) 
        fit$strata <- factor(rep(1:nstrat, fit$strata), 1:nstrat,
                             labels= names(fit$strata))
    class(fit) <- "summary.survfit"
    fit
}
@ 

The simple case of no times argument.
<<survfitms-simple>>=
if (!censored) {
    index <- (rowSums(as.matrix(fit$n.event)) >0)
    for (i in c("time","n.risk", "n.event", "surv", "pstate", "std.err", 
                        "upper", "lower", "cumhaz", "std.chaz")) {
        if (!is.null(fit[[i]])) {  # not all components in all objects
            temp <- fit[[i]]
            if (!is.array(temp)) temp <- temp[index]  #simple vector
            else if (is.matrix(temp)) temp <- temp[index,,drop=FALSE]
            else temp <- temp[,,index, drop=FALSE] # 3 way
            fit[[i]] <- temp
        }
    }
    # The n.enter and n.censor values are accumualated
    #  both of these are simple vectors
    if (is.null(fit$strata)) {
        for (i in c("n.enter", "n.censor"))
            if (!is.null(fit[[i]]))
                fit[[i]] <- delta(fit[[i]], index)
    }
    else {
        sindx <- rep(1:nstrat, fit$strata)
        for (i in c("n.enter", "n.censor")) {
            if (!is.null(fit[[i]]))
                fit[[i]] <- unlist(sapply(1:nstrat, function(j) 
                             delta(fit[[i]][sindx==j], index[sindx==j])))
        }
        # the "factor" is needed for the case that a strata has no
        #  events at all, and hence 0 lines of output
        fit$strata[] <- as.vector(table(factor(sindx[index], 1:nstrat))) 
    }
}
#if missing(times) and censored=TRUE, the fit object is ok as it is
@ 

To deal with selected times we first define a subscripting function.
For indices of 0, which are requested times that are before the first event,
it fills in an initial value. 

<<survfitms-times>>=
ssub <- function(x, indx, init=0) {  #select an object and index
    if (!is.null(x) && length(indx)>0) {
        # the as.vector() is a way to keep R from adding "init" as a row name
        if (is.matrix(x)) rbind(as.vector(init), x)[indx+1,,drop=FALSE]
        else c(init, x)[indx+1]
    }
    else NULL
}
@ 

This function does the real work, for any single curve.
The default value for init is correct for survival curves.

Say that the data has values at time 5, 10, 15, 20 \ldots, and a user asks
for \code{times=c(7, 15, 20, 30)}.  
In the input object \code{n.risk} refers to the number at risk just before
time 5, 10, \ldots; it is a left-continuous function.  
The survival is a right-continuous function.  So at time 7 we want to 
take the survival from time 5 and number at risk from time 10;
\code{indx1} will be the right-continuous index and \code{indx2} the
left continuous one. The value of n.risk at time 30 has to be computed.
For counts of events, censoring, and entry we want to know the total
number that happened during the intervals of 0-7, 7-15, 15-20 and 20-30.
Technically censorings at time 15 happen just after time 15 so would
go into the third line of the report.
However, this would lead to terrible confusion for the user since
using \code{times=c(5, 10, 15, 20)} would lead to different counts than
a call that did not contain the times argument, so all 3 of the intermediates
are computed using indx1.
A report at time 30 is made only if extend=TRUE, in which case we need
to compute a tail value for n.risk.
<<survfitms-times>>=
findrow <- function(fit, times, extend, init=1) {
    # First, toss any printing times that are outside our range
    if (is.null(fit$start.time)) mintime <- min(fit$time, 0)
    else                         mintime <- fit$start.time
    ptimes <- times[times >= mintime]

    if (!extend) {
        maxtime <- max(fit$time)
        ptimes <- ptimes[ptimes <= maxtime]
    }
    ntime <- length(fit$time)
    
    index1 <- findInterval(ptimes, fit$time) 
    index2 <- 1 + findInterval(ptimes, fit$time, left.open=TRUE)
    # The pmax() above encodes the assumption that n.risk for any
    #  times before the first observation = n.risk at the first obs
    fit$time <- ptimes
    for (i in c("surv", "pstate", "upper", "lower")) {
        if (!is.null(fit[[i]])) fit[[i]] <- ssub(fit[[i]], index1, init)
    }
    for (i in c("std.err", "cumhaz")) {
        if (!is.null(fit[[i]])) fit[[i]] <- ssub(fit[[i]], index1, 0)
    }
    
    if (is.matrix(fit$n.risk)) {
        # Every observation in the data has to end with a censor or event.
        #  So by definition the number at risk after the last observed time
        #  value must be 0.
        fit$n.risk <- rbind(fit$n.risk,0)[index2,,drop=FALSE]
    }
    else  fit$n.risk <- c(fit$n.risk, 0)[index2]

    for (i in c("n.event", "n.censor", "n.enter"))
        fit[[i]] <- delta(fit[[i]], index1)
    fit
}

# For a single component, turn it from a list into a single vector, matrix
#  or array
unlistsurv <- function(x, name) {
    temp <- lapply(x, function(x) x[[name]])
    if (is.vector(temp[[1]])) unlist(temp)
    else if (is.matrix(temp[[1]])) do.call("rbind", temp)
    else { 
        # the cumulative hazard is the only component that is an array
        # it's third dimension is n
        xx <- unlist(temp)
        dd <- dim(temp[[1]])
        dd[3] <- length(xx)/prod(dd[1:2])
        array(xx, dim=dd)
    }
}

# unlist all the components built by a set of calls to findrow
#  and remake the strata
unpacksurv <- function(fit, ltemp) {
    keep <- c("time", "surv", "pstate", "upper", "lower", "std.err",
              "cumhaz", "n.risk", "n.event", "n.censor", "n.enter",
              "std.chaz")
    for (i in keep) 
        if (!is.null(fit[[i]])) fit[[i]] <- unlistsurv(ltemp, i)
    fit$strata[] <- sapply(ltemp, function(x) length(x$time))
    fit
}
@ 

Repeat the code for survfitms objects.  The only real difference is
the preservation of \code{pstate} and \code{cumhaz} instead of \code{surv},
and the use of survmean2.

<<survfitms-summary>>=
summary.survfitms <- function(object, times, censored=FALSE, 
			    scale=1, extend=FALSE, 
                            rmean= getOption("survfit.rmean"),
                            ...) {
    fit <- survfit23(object)
    if (!inherits(fit, 'survfitms'))
	    stop("summary.survfitms can only be used for survfitms objects")
    if (is.null(fit$logse)) fit$logse <- FALSE  # older style

    # The print.rmean option is depreciated, it is still listened
    #   to in print.survfit, but ignored here
    if (is.null(rmean)) rmean <- "common"
    if (is.numeric(rmean)) {
        if (is.null(object$start.time)) {
            if (rmean < min(object$time)) 
                stop("Truncation point for the mean is < smallest survival")
        }
        else if (rmean < object$start.time)
            stop("Truncation point for the mean is < smallest survival")
    }
    else {
        rmean <- match.arg(rmean, c('none', 'common', 'individual'))
        if (length(rmean)==0) stop("Invalid value for rmean option")
    }

    temp <- survmean2(fit, scale=scale, rmean)  
    table <- temp$matrix  #for inclusion in the output list
    rmean.endtime <- temp$end.time

    if (!missing(times)) {
        if (!is.numeric(times)) stop ("times must be numeric")
        times <- sort(times)
    }
    fit$time <- fit$time/scale
    if (!is.null(fit$strata)) {
        nstrat <-  length(fit$strata)
        sindx <- rep(1:nstrat, fit$strata)
    }    
    delta <- function(x, indx) {  # sums between chosen times
        if (is.logical(indx)) indx <- which(indx)
        if (!is.null(x) && length(indx) >0) {
            fx <- function(x, indx) diff(c(0, c(0, cumsum(x))[indx+1]))
            if (is.matrix(x)) {
                temp <- apply(x, 2, fx, indx=indx)
                if (is.matrix(temp)) temp else matrix(temp, nrow=1)
            }
            else fx(x, indx)
        }
        else NULL
    }

    if (missing(times)) {
        <<survfitms-simple>>
    }
    else {
        <<survfitms-times>>
        times <- sort(times)
        if (is.null(fit$strata)) fit <- findrow(fit, times, extend, fit$p0)
        else {
            ltemp <- vector("list", nstrat)
            for (i in 1:nstrat) 
                ltemp[[i]] <- findrow(fit[i], times, extend, fit$p0[i,])
            fit <- unpacksurv(fit, ltemp)
        }
    }

    # finish off the output structure
    fit$table <- table
    if (length(rmean.endtime)>0  && !any(is.na(rmean.endtime))) 
            fit$rmean.endtime <- rmean.endtime

    if (!is.null(fit$strata)) 
        fit$strata <- factor(rep(names(fit$strata), fit$strata))

    # A survfit object may contain std(log S) or std(S), summary always std(S)
    if (!is.null(fit$std.err) && fit$logse) fit$std.err <- fit$std.err * fit$surv 

    class(fit) <- "summary.survfitms"
    fit
}

<<printms>>
<<survmean2>>
@ 

Printing for a survfitms object is different than for a survfit one.
The big difference is that I don't have an estimate of the median, or
any other quantile for that matter.  Mean time in state makes sense, but
I don't have a standard error for it at the moment.
The other is that there is usually a mismatch between the n.event matrix
and the n.risk matrix.  
The latter has all the states that were possible whereas the former only
has states with an arrow pointing in.  We need to manufacture the 0 events
for the other states.

<<printms>>=
print.survfitms <- function(x, scale=1,
                            rmean = getOption("survfit.rmean"), ...) {
    if (!is.null(cl<- x$call)) {
	cat("Call: ")
	dput(cl)
	cat("\n")
        }	
    omit <- x$na.action
    if (length(omit)) cat("  ", naprint(omit), "\n")

    x <- survfit23(x)
    if (is.null(rmean)) rmean <- "common"
    if (is.numeric(rmean)) {
        if (is.null(x$start.time)) {
            if (rmean < min(x$time)) 
                stop("Truncation point for the mean is < smallest survival")
        }
        else if (rmean < x$start.time)
            stop("Truncation point for the mean is < smallest survival")
    }
    else {
        rmean <- match.arg(rmean, c('none', 'common', 'individual'))
        if (length(rmean)==0) stop("Invalid value for rmean option")
    }

    temp <- survmean2(x, scale=scale, rmean)
    if (is.null(temp$end.time)) print(temp$matrix, ...)
    else {
        etime <- temp$end.time
        dd <- dimnames(temp$matrix)
        cname <- dd[[2]]
        cname[length(cname)] <- paste0(cname[length(cname)], '*')
        dd[[2]] <- cname
        dimnames(temp$matrix) <- dd
        print(temp$matrix, ...)
        if (length(etime) ==1)
             cat("   *mean time in state, restricted (max time =", 
                 format(etime, ...), ")\n")
        else cat("   *mean time in state, restricted (per curve cutoff)\n")
    }
    invisible(x)
}
@ 

This part of the computation is set out separately since it is called
by both print and summary.
<<survmean2>>=
survmean2 <- function(x, scale=1, rmean) {
    nstate <- length(x$states)  #there will always be at least 1 state
    ngrp   <- max(1, length(x$strata))
    if (ngrp >1)  {
        igrp <- rep(1:ngrp, x$strata)
        rname <- names(x$strata)
        }
    else {
        igrp <- rep(1, length(x$time))
        rname <- NULL
        }

    # The n.event matrix may not have nstate columms.  Its
    #  colnames are the first elements of states, however
    if (is.matrix(x$n.event)) {
        nc <- ncol(x$n.event)
        nevent <- tapply(x$n.event, list(rep(igrp, nc), col(x$n.event)), sum)
        dimnames(nevent) <- list(rname, x$states[1:nc])
        }
    else {
        nevent <- tapply(x$n.event, igrp, sum)
        names(nevent) <- rname
        }

    outmat <- matrix(0., nrow=nstate*ngrp , ncol=2)
    outmat[,1] <- rep(x$n, nstate)
    outmat[1:length(nevent), 2] <- c(nevent)
  
    if (ngrp >1) 
        rowname <- c(outer(rname, x$states, paste, sep=", "))
    else rowname <- x$states

    # Caculate the mean time in each state
    if (rmean != "none") {
        if (is.numeric(rmean)) maxtime <- rep(rmean, ngrp)
        else if (rmean=="common") maxtime <- rep(max(x$time), ngrp)
        else maxtime <- tapply(x$time, igrp, max)
    
        meantime <- matrix(0., ngrp, nstate)
        if (!is.null(x$influence)) stdtime <- meantime
        for (i in 1:ngrp) {
            if (is.matrix(x$pstate))
                temp <- x$pstate[igrp==i,, drop=FALSE]
            else temp <- matrix(x$pstate[igrp==i], ncol=1)

            tt <- x$time[igrp==i]
 
            # Now cut it off at maxtime
            delta <- diff(c(tt[tt<maxtime[i]], maxtime[i]))
            if (length(delta) > nrow(temp)) delta <- delta[1:nrow(temp)]
            if (length(delta) < nrow(temp))
                delta <- c(delta, rep(0, nrow(temp) - length(delta)))
            meantime[i,] <- colSums(delta*temp)

            if (!is.null(x$influence)) {
                # calculate the variance
                if (is.list(x$influence))
                    itemp <- apply(x$influence[[i]], 1,
                                   function(x) colSums(x*delta))
                else itemp <- apply(x$influence, 1,
                                    function(x) colSums(x*delta))
                stdtime[i,] <- sqrt(rowSums(itemp^2))
           }
        }
        outmat <- cbind(outmat, c(meantime)/scale)
        cname <- c("n", "nevent", "rmean")
        if (!is.null(x$influence)) {
            outmat <- cbind(outmat, c(stdtime)/scale)
            cname <- c(cname, "std(rmean)")
        }
        # report back a single time, if there is only one
        if (all(maxtime == maxtime[1])) maxtime <- maxtime[1]
    }
    else cname <- c("n", "nevent")
    dimnames(outmat) <- list(rowname, cname)

    if (rmean=='none') list(matrix=outmat)
    else list(matrix=outmat, end.time=maxtime/scale)
}
@ 
